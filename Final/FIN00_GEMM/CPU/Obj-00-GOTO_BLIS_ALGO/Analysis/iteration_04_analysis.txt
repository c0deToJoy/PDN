ITERATION 4: tuned\_variant01\_op
================================================================================

1. CODE CHANGES FROM PREVIOUS ITERATION
--------------------------------------------------------------------------------
Introduces the first level of cache blocking by adding BLOCK\_NC (n-dimension blocking, default 192). The outer j-loop now iterates in blocks of BLOCK\_NC:

```c
int n0\_fringe\_start = n0 - (n0\%(BLOCK\_NC));

// Steady State
for( int j0\_o = 0; j0\_o < n0\_fringe\_start; j0\_o += BLOCK\_NC )
  for( int p0 = 0; p0 < k0; ++p0 )
    for( int i0 = 0; i0 < m0; ++i0 )
      for( int j0\_i = 0; j0\_i < BLOCK\_NC; ++j0\_i )
        {
          int j0 = j0\_o + j0\_i;
          float A\_ip = A\_distributed[i0 * cs\_A + p0 * rs\_A];
          float B\_pj = B\_distributed[p0 * cs\_B + j0 * rs\_B];
          C\_distributed[i0 * cs\_C + j0 * rs\_C]  += A\_ip*B\_pj;
        }

// Fringe for n0
for( int j0 = n0\_fringe\_start; j0 < n0; ++j0 )
  for( int p0 = 0; p0 < k0; ++p0 )
    for( int i0 = 0; i0 < m0; ++i0 )
      {
        float A\_ip = A\_distributed[i0 * cs\_A + p0 * rs\_A];
        float B\_pj = B\_distributed[p0 * cs\_B + j0 * rs\_B];
        C\_distributed[i0 * cs\_C + j0 * rs\_C]  += A\_ip*B\_pj;
      }
```

This partitions the n-dimension (columns of C) into vertical panels that fit better in L3 cache, reducing cache misses when accessing C repeatedly.

2. PERFORMANCE ANALYSIS
--------------------------------------------------------------------------------
Performance data from CSV files:

Performance data not available in CSV format

Corresponding plot: results/plot\_iter\_04\_tuned\_variant01\_op.png


3. EXPLANATION AND HYPOTHESIS
---------------------------------------------------------------------------------
Good: BLOCK\_NC blocking improves cache locality on the n-dimension by working on vertical panels of C that better fit in L3, reducing cache misses and boosting reuse of B and C columns.

Why performance can crash (or regress) at larger sizes: if the chosen BLOCK\_NC (192) does not fit well in the last-level cache for bigger matrices, the working set of C+B for a panel can exceed L3 capacity, causing cache thrashing and a sharp drop in throughput. Because this variant only blocks along n (not k or m), the B panel is reused well, but A and C footprints can still grow beyond cache as m or k increase, leading to bandwidth stalls and an apparent performance “crash.” The optimization is beneficial when the panel fits comfortably in cache; once the footprint exceeds cache, the benefit can reverse.

To validate:
- Profile cache misses (perf stat -e cache-misses,cache-references)
- Check LLC occupancy vs. panel size (BLOCK\_NC=192) for larger m,k
- Experiment with smaller BLOCK\_NC to see if throughput stabilizes for big problems



























































