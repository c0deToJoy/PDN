ITERATION 5: tuned\_variant02\_op
================================================================================

1. CODE CHANGES FROM PREVIOUS ITERATION
--------------------------------------------------------------------------------
Adds BLOCK\_KC (k-dimension blocking, default 128) to the existing BLOCK\_NC blocking. Now both the k-loop (reduction dimension) and n-loop are blocked:

```c
int n0\_fringe\_start = n0 - (n0\%(BLOCK\_NC));
int k0\_fringe\_start = k0 - (k0\%(BLOCK\_KC));

// Steady State
for( int j0\_o = 0; j0\_o < n0\_fringe\_start; j0\_o += BLOCK\_NC )
  {
Performance data (GFLOPs, 2 ranks):
- Variant 01 (iteration 4, NC only): 128×128×128 = 26.18
- Variant 02 (iteration 5, NC + KC): 128×128×128 = 28.92 (+10.5%)
- Variant 02 degrades to ~2–3 GFLOPs at 192×192×192 and larger

Corresponding plot: results/plot_iter_05_tuned_variant02_op.png
          {
            int j0 = j0\_o + j0\_i;
            int p0 = p0\_o + p0\_i;
            float A\_ip = A\_distributed[i0 * cs\_A + p0 * rs\_A];
            float B\_pj = B\_distributed[p0 * cs\_B + j0 * rs\_B];
            C\_distributed[i0 * cs\_C + j0 * rs\_C]  += A\_ip*B\_pj;
          }

    // Fringe for k0
    for( int p0 = k0\_fringe\_start; p0 < k0; ++p0 )
      for( int i0 = 0; i0 < m0; ++i0 )
        for( int j0\_i = 0; j0\_i < BLOCK\_NC; ++j0\_i )
          {
            int j0 = j0\_o + j0\_i;
            float A\_ip = A\_distributed[i0 * cs\_A + p0 * rs\_A];
            float B\_pj = B\_distributed[p0 * cs\_B + j0 * rs\_B];
            C\_distributed[i0 * cs\_C + j0 * rs\_C]  += A\_ip*B\_pj;
          }
  }
```

This ensures that panels of A (m×BLOCK\_KC) and B (BLOCK\_KC×n) fit in L2/L3 cache during the inner product accumulation, significantly improving data reuse.

2. PERFORMANCE ANALYSIS
--------------------------------------------------------------------------------
Performance data from CSV files:

Performance data not available in CSV format

Corresponding plot: results/plot\_iter\_05\_tuned\_variant02\_op.png


3. EXPLANATION AND HYPOTHESIS
--------------------------------------------------------------------------------
Good: Adding BLOCK_KC blocks the reduction dimension so A and B panels (m×BLOCK_KC, BLOCK_KC×n) stay resident in cache during the inner product, giving +10.5% at 128×128×128 versus iteration 4.

Why performance “crashes” at larger sizes: With NC=192 and KC=128, the combined A/B/C panel footprint grows past LLC once m,n,k reach 192, triggering cache thrash and bandwidth stalls; throughput falls to ~2–3 GFLOPs and may appear as a stall/regression.

To validate and mitigate:
- Profile cache misses (perf stat -e cache-misses,cache-references)
- Check LLC fit for A/B/C panels at larger m,n,k
- Reduce BLOCK_NC or BLOCK_KC to keep the working set within L3
