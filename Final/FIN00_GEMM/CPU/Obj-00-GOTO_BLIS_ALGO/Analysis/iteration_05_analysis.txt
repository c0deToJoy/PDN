ITERATION 5: tuned_variant02_op
================================================================================

1. CODE CHANGES FROM PREVIOUS ITERATION
--------------------------------------------------------------------------------
Comparing tuned_variant01_op.c -> tuned_variant02_op.c

Key changes detected:
  - BLOCK_NC (n-dimension blocking) introduced/modified
  - BLOCK_KC (k-dimension blocking) introduced/modified
  - OpenMP/threading introduced

Diff excerpt (first 100 lines of changes):
--- Obj-00-GOTO_BLIS_ALGO/tuned_variant01_op.c	2025-12-05 03:05:55.598484631 +0000
+++ Obj-00-GOTO_BLIS_ALGO/tuned_variant02_op.c	2025-12-05 03:05:55.598484631 +0000
-
+#ifndef BLOCK_KC
+#define BLOCK_KC 128
+#endif /* BLOCK_KC */
+
+      int k0_fringe_start = k0 - (k0%(BLOCK_KC));
-	for( int p0 = 0; p0 < k0; ++p0 )
-	  for( int i0 = 0; i0 < m0; ++i0 )
-	    for( int j0_i = 0; j0_i < BLOCK_NC; ++j0_i )
-	      {
-		int j0 = j0_o + j0_i;
-		float A_ip = A_distributed[i0 * cs_A + p0 * rs_A];
-		float B_pj = B_distributed[p0 * cs_B + j0 * rs_B];
-
-		C_distributed[i0 * cs_C + j0 * rs_C]  += A_ip*B_pj;
-	      }
-
+	{
+	  // Steady State
+	  for( int p0_o = 0; p0_o < k0_fringe_start; p0_o += BLOCK_KC )
+	    for( int i0 = 0; i0 < m0; ++i0 )
+	      for( int j0_i = 0; j0_i < BLOCK_NC; ++j0_i )
+		// Note: This will be moved in later iterations
+		for( int p0_i = 0; p0_i < BLOCK_KC; ++p0_i )
+		{
+		  int j0 = j0_o + j0_i;
+		  int p0 = p0_o + p0_i;
+		  float A_ip = A_distributed[i0 * cs_A + p0 * rs_A];
+		  float B_pj = B_distributed[p0 * cs_B + j0 * rs_B];
+
+		  C_distributed[i0 * cs_C + j0 * rs_C]  += A_ip*B_pj;
+		}
+
+	  // Fringe for k0
+	  for( int p0 = k0_fringe_start; p0 < k0; ++p0 )
+	    for( int i0 = 0; i0 < m0; ++i0 )
+	      for( int j0_i = 0; j0_i < BLOCK_NC; ++j0_i )
+		{
+		  int j0 = j0_o + j0_i;
+		  float A_ip = A_distributed[i0 * cs_A + p0 * rs_A];
+		  float B_pj = B_distributed[p0 * cs_B + j0 * rs_B];
+
+		  C_distributed[i0 * cs_C + j0 * rs_C]  += A_ip*B_pj;
+		}
+	}
...


2. PERFORMANCE ANALYSIS
--------------------------------------------------------------------------------
Performance data from CSV files:

Performance data not available in CSV format

Corresponding plot: results/plot_iter_05_tuned_variant02_op.png


3. EXPLANATION AND HYPOTHESIS
--------------------------------------------------------------------------------
BLOCK_KC introduces blocking in the k-dimension (reduction dimension).
This ensures panels of A and B fit in cache during the inner product,
significantly improving L2/L3 cache reuse.

To test this hypothesis:
- Profile cache miss rates (perf stat -e cache-misses,cache-references)
- Analyze instruction mix and IPC (instructions per cycle)
- Vary block sizes to find optimal values for target architecture
- Compare performance across different matrix sizes and shapes
